import { defineComponent as c, openBlock as a, createElementBlock as i, Fragment as V, renderList as S, createElementVNode as r, toDisplayString as l, renderSlot as v, resolveComponent as _, createBlock as y, resolveDynamicComponent as L, normalizeClass as g, withCtx as k, createVNode as $, createCommentVNode as p, ref as j, Transition as q, mergeProps as O, createTextVNode as w, withModifiers as U, toRef as b, withDirectives as F, vModelDynamic as P, vModelSelect as W, vModelRadio as H, vModelText as G } from "vue";
import { useScrollLock as J } from "@vueuse/core";
import { useField as B } from "vee-validate";
const We = `/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button}button::-moz-focus-inner,[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner{border-style:none;padding:0}button:-moz-focusring,[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}template{display:none}[hidden]{display:none}:root{--theme-primary-color: #FFD01C;--shadow-normal: 0 4px 6px -1px rgba(0, 0, 0, .1), 0 2px 4px -1px rgba(0, 0, 0, .06);--shadow-focus: 0 0 0 3px rgba(0, 10, 30, .1), 0 10px 15px -3px rgba(0, 0, 0, .1), 0 4px 6px -2px rgba(0, 0, 0, .05);--shadow-hover: 0 10px 15px -3px rgba(0, 0, 0, .1), 0 4px 6px -2px rgba(0, 0, 0, .05);--border-radius: 5px;--theme-primary-background: #FFD01C;--theme-primary-text: #000;--theme-primary-border: #D69E2E;--theme-base-background: #FFF;--theme-base-text: #000;--theme-base-border: #EDF2F7;--theme-positive-background: #68D391;--theme-positive-text: #FFF;--theme-positive-border: #38A169;--theme-neutral-background: #e6ebf0;--theme-neutral-text: #4a5568;--theme-neutral-border: #CBD5E0;--theme-negative-background: #FC8181;--theme-negative-text: #FFF;--theme-negative-border: #E53E3E;--theme-disabled-background: #F7FAFC;--theme-disabled-text: #E2E8F0;--theme-disabled-border: #EDF2F7;--theme-gray-background: #CBD5E0;--theme-gray-text: #000;--theme-white-background: #FFF;--theme-white-text: #000;--theme-white-border: #CBD5E0;--theme-primary-dark-background: #D69E2E;--theme-primary-dark-text: #FFF;--theme-primary-dark-border: #975A16;--theme-dark-background: #2D3748;--theme-dark-text: #E2E8F0;--theme-dark-border: #1A202C}*{-webkit-tap-highlight-color:transparent}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}button{background-color:transparent;background-image:none;border:0;cursor:pointer}fieldset{margin:0;padding:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";line-height:1.5}*,:before,:after{box-sizing:border-box}hr{border-top-width:1px}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button:focus,input:focus,textarea:focus{outline:none;box-shadow:0 0 0 3px #cbd5e0}.tooltip *{outline:none!important}h2{font-size:1.5em;line-height:1.25em;font-weight:700;margin-bottom:2em}@media (min-width: 40em){h2{font-size:1.875em}h2+p{font-size:1.25em}}@media (min-width: 60em){h2{font-size:2.25em}h2+p{font-size:1.5em}}
`, A = c({
  name: "AccordionList",
  props: {
    items: {
      type: Array,
      required: !0
    },
    openFirst: {
      type: Boolean,
      default: !1
    }
  }
});
const f = (e, t) => {
  const s = e.__vccOpts || e;
  for (const [d, u] of t)
    s[d] = u;
  return s;
}, K = { class: "accordion-list" }, Q = ["open"];
function X(e, t, s, d, u, h) {
  return a(), i("div", K, [
    (a(!0), i(V, null, S(e.items, (n, o) => (a(), i("details", {
      key: n.alias,
      class: "accordion-list__item",
      open: e.openFirst && o === 0
    }, [
      r("summary", null, l(n.caption), 1),
      v(e.$slots, n.alias)
    ], 8, Q))), 128))
  ]);
}
const He = /* @__PURE__ */ f(A, [["render", X]]);
A.__docgenInfo = { displayName: "AccordionList", description: "Renders an accordion using the elements details and summary.", tags: {}, exportName: "default", props: [{ name: "items", description: "List of items, each with an alias used for the slot name and a caption used for the summary.", type: { name: "Array as () => { alias: string; caption: string }[]" }, required: !0 }, { name: "openFirst", description: "Wether to open the first item in the list by default.", type: { name: "boolean" }, defaultValue: { func: !1, value: "false" } }], slots: [{ name: "default", scoped: !0, bindings: [{ name: "name", title: "binding" }] }] };
const z = c({
  name: "IconDisplay",
  props: {
    name: {
      type: String,
      required: !0
    },
    monospace: {
      type: Boolean,
      default: !0
    },
    spinning: {
      type: Boolean,
      default: !1
    }
  }
});
function Y(e, t, s, d, u, h) {
  const n = _("FontAwesomeIcon");
  return a(), y(n, {
    icon: ["fas", e.name],
    class: "icon",
    "fixed-width": e.monospace,
    spin: e.spinning
  }, null, 8, ["icon", "fixed-width", "spin"]);
}
const T = /* @__PURE__ */ f(z, [["render", Y]]);
z.__docgenInfo = { displayName: "IconDisplay", description: "A simple icon component to display free FontAwesome 5 icons.", tags: {}, exportName: "default", props: [{ name: "name", description: "The FontAwesome icon identifier (snake-case) to be used.", type: { name: "string" }, required: !0 }, { name: "monospace", description: "Wether the width should be the same for all icons or individual.", type: { name: "boolean" }, defaultValue: { func: !1, value: "true" } }, { name: "spinning", description: "Make the icon spin constantly.", type: { name: "boolean" }, defaultValue: { func: !1, value: "false" } }] };
const C = c({
  name: "BaseButton",
  components: {
    IconDisplay: T
  },
  emits: ["click"],
  props: {
    tag: {
      type: String,
      default: "button",
      validator: (e) => ["button", "a"].includes(e)
    },
    href: {
      type: String,
      default: null
    },
    type: {
      type: String,
      default: "button",
      validator: (e) => ["button", "submit", "reset"].includes(e)
    },
    theme: {
      type: String,
      default: "primary",
      validator: (e) => [
        "primary",
        "positive",
        "neutral",
        "negative",
        "white",
        "primary-dark",
        "transparent"
      ].includes(e)
    },
    size: {
      type: String,
      default: "normal",
      validator: (e) => ["small", "normal", "large"].includes(e)
    },
    textAlign: {
      type: String,
      default: "center",
      validator: (e) => ["left", "center"].includes(e)
    },
    left: {
      type: String,
      default: ""
    },
    right: {
      type: String,
      default: ""
    },
    target: {
      type: String,
      default: "_self"
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    tabindex: {
      type: Number,
      default: 0
    }
  },
  computed: {
    classes() {
      const e = [
        `base-button--theme-${this.theme}`,
        `base-button--size-${this.size}`,
        `base-button--text-align-${this.textAlign}`
      ];
      return this.disabled && e.push("base-button--disabled"), e;
    }
  },
  methods: {
    onClick(e) {
      if (this.disabled) {
        e.preventDefault();
        return;
      }
      this.tag === "button" && e.preventDefault(), this.$emit("click", e);
    }
  }
});
const Z = {
  key: 0,
  class: "base-button__left-icon"
}, x = {
  key: 1,
  class: "base-button__caption"
}, ee = {
  key: 2,
  class: "base-button__right-icon"
};
function te(e, t, s, d, u, h) {
  const n = _("IconDisplay");
  return a(), y(L(e.tag), {
    class: g(["base-button", e.classes]),
    disabled: e.disabled,
    tabindex: e.disabled ? -1 : e.tabindex,
    href: e.tag === "a" ? e.href : void 0,
    type: e.tag === "button" ? e.type : void 0,
    target: e.tag === "a" ? e.target : void 0,
    onClick: e.onClick
  }, {
    default: k(() => [
      e.left ? (a(), i("span", Z, [
        $(n, {
          name: e.left,
          monospace: ""
        }, null, 8, ["name"])
      ])) : p("", !0),
      e.$slots.default ? (a(), i("span", x, [
        v(e.$slots, "default")
      ])) : p("", !0),
      e.right ? (a(), i("span", ee, [
        $(n, {
          name: e.right,
          monospace: ""
        }, null, 8, ["name"])
      ])) : p("", !0)
    ]),
    _: 3
  }, 8, ["class", "disabled", "tabindex", "href", "type", "target", "onClick"]);
}
const ae = /* @__PURE__ */ f(C, [["render", te]]);
C.__docgenInfo = { displayName: "BaseButton", description: "Renders a basic button or a-tag with support for icons, themes and sizes.", tags: {}, exportName: "default", props: [{ name: "tag", description: "The HTML tag to be used.", values: ["button", "a"], type: { name: "string" }, defaultValue: { func: !1, value: "'button'" } }, { name: "href", description: "The href attribute \u2013 only applies when tag is set to `a`.", type: { name: "string" }, defaultValue: { func: !1, value: "null" } }, { name: "type", description: "The type of button \u2013 only applies when tag is set to `button`.", values: ["button", "submit", "reset"], type: { name: "string" }, defaultValue: { func: !1, value: "'button'" } }, { name: "theme", description: "The global theme to be used. Can indicate the purpose of the button.", values: ["primary", "positive", "neutral", "negative", "white", "primary-dark", "transparent"], type: { name: "string" }, defaultValue: { func: !1, value: "'primary'" } }, { name: "size", description: "The global size to be used.", values: ["small", "normal", "large"], type: { name: "string" }, defaultValue: { func: !1, value: "'normal'" } }, { name: "textAlign", values: ["left", "center"], type: { name: "string" }, defaultValue: { func: !1, value: "'center'" } }, { name: "left", description: "The FontAwesome icon to be displayed left of the caption.", type: { name: "string" }, defaultValue: { func: !1, value: "''" } }, { name: "right", description: "The FontAwesome icon to be displayed right of the caption.", type: { name: "string" }, defaultValue: { func: !1, value: "''" } }, { name: "target", description: "The link target \u2013 only applies when tag is set to `a`.", type: { name: "string" }, defaultValue: { func: !1, value: "'_self'" } }, { name: "disabled", type: { name: "boolean" }, defaultValue: { func: !1, value: "false" } }, { name: "tabindex", type: { name: "number" }, defaultValue: { func: !1, value: "0" } }], events: [{ name: "click", type: { names: ["undefined"] } }], slots: [{ name: "default" }] };
const N = c({
  name: "ModalView",
  components: {
    BaseButton: ae,
    IconDisplay: T
  },
  setup() {
    const e = j(null);
    return {
      isLocked: J(e)
    };
  },
  props: {
    visible: {
      type: Boolean,
      default: !0
    },
    heading: {
      type: String,
      required: !0
    },
    description: {
      type: String
    },
    buttons: {
      type: Array,
      default: null
    },
    icon: {
      type: String,
      default: null
    },
    width: {
      type: String,
      default: "normal",
      validator: (e) => ["slim", "narrow", "normal", "wide"].includes(e)
    },
    noPadding: {
      type: Boolean,
      default: !1
    }
  },
  mounted() {
    this.$watch("visible", (e) => {
      this.isLocked = e;
    });
  },
  computed: {
    classes() {
      const e = [`modal--width-${this.width}`];
      return this.noPadding && e.push("modal--no-padding"), e;
    },
    defaultButton() {
      return [
        {
          caption: this.$t("ui.modal.done"),
          theme: "primary",
          eventName: "close"
        }
      ];
    }
  }
});
const ne = { class: "modal__wrapper" }, ie = { class: "modal__box" }, le = {
  key: 0,
  class: "modal__header"
}, se = { class: "modal__heading" }, oe = {
  key: 1,
  class: "modal__description"
}, re = {
  key: 1,
  ref: "content",
  class: "modal__content"
}, de = { class: "modal__actions" };
function ue(e, t, s, d, u, h) {
  const n = _("IconDisplay"), o = _("BaseButton");
  return a(), y(q, {
    name: "fade",
    duration: { enter: 300, leave: 200 }
  }, {
    default: k(() => [
      e.visible ? (a(), i("div", {
        key: 0,
        class: g(["modal", e.classes]),
        role: "dialog",
        "aria-labelledby": "modal__heading",
        "aria-describedby": "modal__description"
      }, [
        r("div", ne, [
          r("div", {
            class: "modal__overlay",
            onClick: t[0] || (t[0] = (m) => e.$emit("close"))
          }),
          r("div", ie, [
            e.heading ? (a(), i("div", le, [
              e.icon ? (a(), y(n, {
                key: 0,
                name: e.icon,
                class: "modal__icon",
                spin: e.icon === "slash"
              }, null, 8, ["name", "spin"])) : p("", !0),
              r("h1", se, l(e.heading), 1),
              e.description ? (a(), i("p", oe, l(e.description), 1)) : p("", !0)
            ])) : p("", !0),
            e.$slots.default ? (a(), i("div", re, [
              v(e.$slots, "default")
            ], 512)) : p("", !0),
            r("div", de, [
              (a(!0), i(V, null, S(e.buttons || e.defaultButton, (m) => (a(), y(o, O({
                key: m.eventName
              }, m, {
                class: "modal__action",
                onClick: (je) => m.eventName ? e.$emit(m.eventName) : () => {
                }
              }), {
                default: k(() => [
                  w(l(m.caption), 1)
                ]),
                _: 2
              }, 1040, ["onClick"]))), 128))
            ])
          ])
        ])
      ], 2)) : p("", !0)
    ]),
    _: 3
  });
}
const pe = /* @__PURE__ */ f(N, [["render", ue]]);
N.__docgenInfo = { displayName: "ModalView", description: "Wraps content in a modal that can be hidden and shown programmatically.", tags: {}, exportName: "default", props: [{ name: "visible", description: "Wether the modal is visible.", type: { name: "boolean" }, defaultValue: { func: !1, value: "true" } }, { name: "heading", description: "The heading of the modal.", type: { name: "string" }, required: !0 }, { name: "description", description: "The description of the modal, appearing below the heading.", type: { name: "string" } }, { name: "buttons", description: `An array of actions (buttons) that appear below the modals content. By default, contains a
simple done-button that emits the close-event.`, type: { name: "Array as () => (BaseButtonProps & { eventName: string; caption: string })[]" }, defaultValue: { func: !1, value: "null" } }, { name: "icon", description: "An icon shown above the modal's heading.", type: { name: "string | null" }, defaultValue: { func: !1, value: "null" } }, { name: "width", description: "The width of the modal.", values: ["slim", "narrow", "normal", "wide"], type: { name: "string" }, defaultValue: { func: !1, value: "'normal'" } }, { name: "noPadding", description: "Don't add padding to the modal content.", type: { name: "boolean" }, defaultValue: { func: !1, value: "false" } }], events: [{ name: "close" }, { name: "<undefined>" }], slots: [{ name: "default" }] };
const I = c({
  name: "AsyncButton",
  components: {
    IconDisplay: T,
    ModalView: pe
  },
  emits: ["click", "success", "error"],
  data() {
    return {
      status: "idle",
      error: null,
      resetTimeout: null
    };
  },
  props: {
    action: {
      type: Function,
      required: !0
    },
    type: {
      type: String,
      default: "button",
      validator: (e) => ["button", "submit", "reset"].includes(e)
    },
    theme: {
      type: String,
      default: "primary",
      validator: (e) => [
        "primary",
        "positive",
        "neutral",
        "negative",
        "white",
        "primary-dark",
        "transparent"
      ].includes(e)
    },
    size: {
      type: String,
      default: "normal",
      validator: (e) => ["small", "normal", "large"].includes(e)
    },
    textAlign: {
      type: String,
      default: "center",
      validator: (e) => ["left", "center"].includes(e)
    },
    left: {
      type: String,
      default: ""
    },
    right: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    tabindex: {
      type: Number,
      default: 0
    }
  },
  computed: {
    classes() {
      const e = [
        `async-button--theme-${this.theme}`,
        `async-button--size-${this.size}`,
        `async-button--text-align-${this.textAlign}`
      ];
      return this.disabledOrBusy && e.push("async-button--disabled"), e;
    },
    disabledOrBusy() {
      return this.disabled || this.status === "pending";
    }
  },
  methods: {
    onClick(e) {
      this.$emit("click", e), this.status = "pending", this.action().then((t) => {
        this.status = "success", this.$emit("success", t), this.scheduleStatusReset();
      }, (t) => {
        this.status = "error", this.$emit("error", t), this.error = t.message, this.scheduleStatusReset();
      });
    },
    scheduleStatusReset(e = 3e3) {
      this.resetTimeout && clearTimeout(this.resetTimeout), this.resetTimeout = setTimeout(() => {
        this.status = "idle";
      }, e);
    }
  }
});
const me = ["disabled", "tabindex", "type"], ce = {
  key: 0,
  class: "icon"
}, fe = {
  key: 1,
  class: "async-button__caption"
};
function he(e, t, s, d, u, h) {
  const n = _("IconDisplay"), o = _("ModalView");
  return a(), i("div", null, [
    r("button", {
      class: g(["async-button", e.classes]),
      disabled: e.disabledOrBusy,
      tabindex: e.disabledOrBusy ? -1 : e.tabindex,
      type: e.type,
      onClick: t[0] || (t[0] = U((m) => e.onClick(m), ["stop"]))
    }, [
      e.left || e.right ? (a(), i("span", {
        key: 0,
        class: g(["async-button__icon", `async-button__icon--${e.left ? "left" : "right"}`])
      }, [
        $(q, { name: "icon" }, {
          default: k(() => [
            e.status === "pending" ? (a(), i("div", ce, [
              $(n, {
                key: "pending",
                ref: "pending-icon",
                name: "slash",
                monospace: "",
                spinning: ""
              }, null, 512)
            ])) : e.status === "success" ? (a(), y(n, {
              key: "success",
              ref: "success-icon",
              name: "check",
              monospace: ""
            }, null, 512)) : e.status === "error" ? (a(), y(n, {
              key: "error",
              ref: "error-icon",
              name: "times",
              monospace: ""
            }, null, 512)) : (a(), y(n, {
              key: "icon",
              ref: "icon",
              name: e.left ? e.left : e.right,
              monospace: ""
            }, null, 8, ["name"]))
          ]),
          _: 1
        })
      ], 2)) : p("", !0),
      e.$slots.default ? (a(), i("span", fe, [
        v(e.$slots, "default")
      ])) : p("", !0)
    ], 10, me),
    $(o, {
      visible: e.error !== null,
      heading: e.$t("ui.async-button.error.heading"),
      icon: "times",
      width: "slim",
      buttons: [
        {
          caption: e.$t("ui.async-button.error.okay-button"),
          theme: "primary",
          eventName: "close"
        }
      ],
      onClose: t[1] || (t[1] = (m) => e.error = null)
    }, {
      default: k(() => [
        w(l(e.error), 1)
      ]),
      _: 1
    }, 8, ["visible", "heading", "buttons"])
  ]);
}
const Ge = /* @__PURE__ */ f(I, [["render", he]]);
I.__docgenInfo = { displayName: "AsyncButton", description: `Renders a basic button with support for icons, themes and sizes. Will execute a given async
function on click, display a loading animation, indicate success or show an error message in a
modal.`, tags: {}, exportName: "default", props: [{ name: "action", description: `The asynchronous function to execute when the button is clicked. Will trigger the loading
animation and wait for the promise to resolve.`, type: { name: "() => Promise<unknown>" }, required: !0 }, { name: "type", description: "The type of button.", values: ["button", "submit", "reset"], type: { name: "string" }, defaultValue: { func: !1, value: "'button'" } }, { name: "theme", description: "The global theme to be used. Can indicate the purpose of the button.", type: { name: "string" }, defaultValue: { func: !1, value: "'primary'" }, values: ["primary", "positive", "neutral", "negative", "white", "primary-dark", "transparent"] }, { name: "size", description: "The global size to be used.", type: { name: "string" }, defaultValue: { func: !1, value: "'normal'" }, values: ["small", "normal", "large"] }, { name: "textAlign", type: { name: "string" }, defaultValue: { func: !1, value: "'center'" }, values: ["left", "center"] }, { name: "left", description: "The FontAwesome icon to be displayed left of the caption.", type: { name: "string" }, defaultValue: { func: !1, value: "''" } }, { name: "right", description: "The FontAwesome icon to be displayed right of the caption.", type: { name: "string" }, defaultValue: { func: !1, value: "''" } }, { name: "disabled", type: { name: "boolean" }, defaultValue: { func: !1, value: "false" } }, { name: "tabindex", type: { name: "number" }, defaultValue: { func: !1, value: "0" } }], events: [{ name: "click", type: { names: ["undefined"] } }, { name: "success", type: { names: ["undefined"] } }, { name: "error", type: { names: ["undefined"] } }], slots: [{ name: "default" }] };
const D = c({
  name: "FieldInput",
  data() {
    return {
      currentValidation: null
    };
  },
  emits: ["update:value"],
  setup(e) {
    const t = b(e, "alias"), s = b(e, "name");
    return {
      field: B(t, e.rules, {
        label: s,
        type: e.type,
        initialValue: e.value
      })
    };
  },
  watch: {
    value(e) {
      this.field.setValue(e);
    }
  },
  props: {
    alias: {
      type: String,
      required: !0
    },
    name: {
      type: String,
      required: !0
    },
    label: {
      type: String,
      required: !0
    },
    type: {
      type: String,
      required: !0,
      validator: (e) => ["email", "file", "number", "password", "tel", "text", "url"].includes(e)
    },
    value: {
      type: String,
      default: null
    },
    rules: {
      type: [String, Object],
      required: !0
    },
    placeholder: {
      type: String,
      default: ""
    },
    description: {
      type: String,
      default: ""
    },
    autocomplete: {
      type: String,
      default: void 0
    },
    readonly: {
      type: Boolean,
      default: !1
    }
  },
  methods: {
    publish() {
      this.field.handleBlur(), this.currentValidation = this.field.validate().then((e) => {
        this.currentValidation = null, e.valid && this.field.value.value !== null ? this.$emit("update:value", this.field.value.value) : this.$emit("update:value", "");
      });
    }
  }
});
const ye = ["for"], ge = ["type", "name", "id", "placeholder", "autocomplete", "readonly"], be = {
  key: 0,
  class: "field-input__description"
}, ve = {
  key: 1,
  class: "field-input__error"
};
function _e(e, t, s, d, u, h) {
  return a(), i("div", {
    class: g({
      "field-input": !0,
      "field-input--invalid": e.field.errors.value.length > 0,
      "field-input--valid": e.field.errors.value.length <= 0 && e.field.meta.dirty
    })
  }, [
    r("label", {
      for: e.alias,
      class: "field-input__label"
    }, l(e.label), 9, ye),
    F(r("input", {
      class: "field-input__input",
      type: e.type,
      name: e.alias,
      id: `field-${e.alias}`,
      placeholder: e.placeholder,
      autocomplete: e.autocomplete,
      readonly: e.readonly,
      "onUpdate:modelValue": t[0] || (t[0] = (n) => e.field.value.value = n),
      onBlur: t[1] || (t[1] = (...n) => e.publish && e.publish(...n)),
      onChange: t[2] || (t[2] = (...n) => e.field.handleChange && e.field.handleChange(...n))
    }, null, 40, ge), [
      [P, e.field.value.value]
    ]),
    e.field.errors.value.length < 1 ? (a(), i("small", be, [
      v(e.$slots, "description", {}, () => [
        w(l(e.description), 1)
      ])
    ])) : (a(), i("small", ve, l(e.field.errors.value[0]), 1))
  ], 2);
}
const Je = /* @__PURE__ */ f(D, [["render", _e]]);
D.__docgenInfo = { displayName: "FieldInput", description: `Renders a textual input field, like text, email, number, etc. together with a label, description
and validation.`, tags: {}, exportName: "default", props: [{ name: "alias", description: "The name of the field in kebab-case.", type: { name: "string" }, required: !0 }, { name: "name", description: "The human readable name of the field.", type: { name: "string" }, required: !0 }, { name: "label", description: "The label above the field.", type: { name: "string" }, required: !0 }, { name: "type", description: "The input type.", values: ["email", "file", "number", "password", "tel", "text", "url"], type: { name: "string" }, required: !0 }, { name: "value", type: { name: "string" }, defaultValue: { func: !1, value: "null" } }, { name: "rules", description: "A set of vee-validate rules.", type: { name: "string | Record<string, unknown>" }, required: !0 }, { name: "placeholder", type: { name: "string" }, defaultValue: { func: !1, value: "''" } }, { name: "description", description: "The description below the field.", type: { name: "string" }, defaultValue: { func: !1, value: "''" } }, { name: "autocomplete", type: { name: "string" }, defaultValue: { func: !1, value: "undefined" } }, { name: "readonly", type: { name: "boolean" }, defaultValue: { func: !1, value: "false" } }], events: [{ name: "update:value", type: { names: ["undefined"] } }], slots: [{ name: "description" }] };
const E = c({
  name: "FieldSelect",
  components: {
    IconDisplay: T
  },
  data() {
    return {
      currentValidation: null
    };
  },
  emits: ["update:value"],
  setup(e) {
    const t = b(e, "alias"), s = b(e, "name");
    return {
      field: B(t, e.rules, {
        label: s,
        initialValue: e.value
      })
    };
  },
  watch: {
    value(e) {
      this.field.setValue(e);
    }
  },
  props: {
    alias: {
      type: String,
      required: !0
    },
    name: {
      type: String,
      required: !0
    },
    label: {
      type: String,
      required: !0
    },
    value: {
      type: String,
      default: null
    },
    options: {
      type: Array,
      required: !0
    },
    rules: {
      type: [String, Object],
      required: !0
    },
    description: {
      type: String,
      default: ""
    },
    readonly: {
      type: Boolean,
      default: !1
    }
  },
  methods: {
    publish() {
      this.currentValidation = this.field.validate().then((e) => {
        this.currentValidation = null, e.valid && this.field.value.value !== null ? this.$emit("update:value", this.field.value.value) : this.$emit("update:value", "");
      });
    }
  }
});
const $e = ["for"], we = ["name", "id", "readonly"], ke = {
  value: null,
  disabled: ""
}, Ve = ["value"], Se = {
  key: 0,
  class: "field-select__description"
}, Fe = {
  key: 1,
  class: "field-select__error"
};
function Be(e, t, s, d, u, h) {
  const n = _("IconDisplay");
  return a(), i("div", {
    class: g({
      "field-select": !0,
      "field-select--invalid": e.field.errors.value.length > 0,
      "field-select--valid": e.field.errors.value.length <= 0 && e.field.meta.dirty
    })
  }, [
    r("label", {
      for: e.alias,
      class: "field-select__label"
    }, l(e.label), 9, $e),
    $(n, {
      name: "angle-down",
      class: "field-select__icon"
    }),
    F(r("select", {
      class: "field-select__select",
      name: e.alias,
      id: `field-${e.alias}`,
      readonly: e.readonly,
      "onUpdate:modelValue": t[0] || (t[0] = (o) => e.field.value.value = o),
      onBlur: t[1] || (t[1] = (...o) => e.field.handleBlur && e.field.handleBlur(...o)),
      onChange: t[2] || (t[2] = (...o) => e.publish && e.publish(...o))
    }, [
      r("option", ke, l(e.$t("ui.fields.select.choose")), 1),
      (a(!0), i(V, null, S(e.options, (o) => (a(), i("option", {
        key: o.value,
        value: o.value
      }, l(o.option), 9, Ve))), 128))
    ], 40, we), [
      [W, e.field.value.value]
    ]),
    e.field.errors.value.length < 1 ? (a(), i("small", Se, [
      v(e.$slots, "description", {}, () => [
        w(l(e.description), 1)
      ])
    ])) : (a(), i("small", Fe, l(e.field.errors.value[0]), 1))
  ], 2);
}
const Ke = /* @__PURE__ */ f(E, [["render", Be]]);
E.__docgenInfo = { displayName: "FieldSelect", description: "Renders a select field together with a label, description and validation.", tags: {}, exportName: "default", props: [{ name: "alias", description: "The name of the field in kebab-case.", type: { name: "string" }, required: !0 }, { name: "name", description: "The human readable name of the field.", type: { name: "string" }, required: !0 }, { name: "label", description: "The label above the field.", type: { name: "string" }, required: !0 }, { name: "value", type: { name: "string" }, defaultValue: { func: !1, value: "null" } }, { name: "options", description: "An array of options in this form: `{ value: string, option: string }`.", type: { name: "Array as () => { option: string; value: string }[]" }, required: !0 }, { name: "rules", description: "A set of vee-validate rules.", type: { name: "string | Record<string, unknown>" }, required: !0 }, { name: "description", description: "The description below the field.", type: { name: "string" }, defaultValue: { func: !1, value: "''" } }, { name: "readonly", type: { name: "boolean" }, defaultValue: { func: !1, value: "false" } }], events: [{ name: "update:value", type: { names: ["undefined"] } }], slots: [{ name: "description" }] };
const R = c({
  name: "FieldSwitch",
  data() {
    return {
      currentValidation: null
    };
  },
  emits: ["update:value"],
  setup(e) {
    const t = b(e, "alias"), s = b(e, "name");
    return {
      field: B(t, e.rules, {
        label: s,
        type: "radio",
        initialValue: e.value
      })
    };
  },
  watch: {
    value(e) {
      var t;
      (t = this.field) == null || t.setValue(e);
    }
  },
  props: {
    alias: {
      type: String,
      required: !0
    },
    name: {
      type: String,
      required: !0
    },
    label: {
      type: String,
      required: !0
    },
    value: {
      type: String,
      default: null
    },
    options: {
      type: Array,
      required: !0
    },
    rules: {
      type: [String, Object],
      required: !0
    },
    description: {
      type: String,
      default: ""
    },
    readonly: {
      type: Boolean,
      default: !1
    }
  },
  methods: {
    publish() {
      this.currentValidation = this.field.validate().then((e) => {
        this.currentValidation = null, e.valid && this.field.value.value !== null ? this.$emit("update:value", this.field.value.value) : this.$emit("update:value", "");
      });
    }
  }
});
const Te = ["for"], qe = { class: "field-switch__radio-group" }, Ae = ["name", "id", "value", "readonly"], ze = ["for"], Ce = {
  key: 0,
  class: "field-switch__description"
}, Ne = {
  key: 1,
  class: "field-switch__error"
};
function Ie(e, t, s, d, u, h) {
  return a(), i("div", {
    class: g({
      "field-switch": !0,
      "field-switch--invalid": e.field.errors.value.length > 0,
      "field-switch--valid": e.field.errors.value.length <= 0 && e.field.meta.dirty
    })
  }, [
    r("label", {
      for: e.alias,
      class: "field-switch__label"
    }, l(e.label), 9, Te),
    r("div", qe, [
      (a(!0), i(V, null, S(e.options, (n) => (a(), i("div", {
        key: n.value,
        class: "field-switch__radio-button"
      }, [
        F(r("input", {
          class: "field-switch__input",
          type: "radio",
          name: e.alias,
          id: `field-${e.alias}-${n.value}`,
          value: n.value,
          readonly: e.readonly,
          "onUpdate:modelValue": t[0] || (t[0] = (o) => e.field.value.value = o),
          onChange: t[1] || (t[1] = (...o) => e.publish && e.publish(...o))
        }, null, 40, Ae), [
          [H, e.field.value.value]
        ]),
        r("label", {
          class: "field-switch__button",
          for: `field-${e.alias}-${n.value}`
        }, l(n.option), 9, ze)
      ]))), 128))
    ]),
    e.field.errors.value.length < 1 ? (a(), i("small", Ce, [
      v(e.$slots, "description", {}, () => [
        w(l(e.description), 1)
      ])
    ])) : (a(), i("small", Ne, l(e.field.errors.value[0]), 1))
  ], 2);
}
const Qe = /* @__PURE__ */ f(R, [["render", Ie]]);
R.__docgenInfo = { displayName: "FieldSwitch", description: "Renders a radio group but in a switch-like design.", tags: {}, exportName: "default", props: [{ name: "alias", description: "The name of the field in kebab-case.", type: { name: "string" }, required: !0 }, { name: "name", description: "The human readable name of the field.", type: { name: "string" }, required: !0 }, { name: "label", description: "The label above the field.", type: { name: "string" }, required: !0 }, { name: "value", type: { name: "string" }, defaultValue: { func: !1, value: "null" } }, { name: "options", description: "An array of options in this form: `{ value: string, option: string }`.", type: { name: "Array as () => { value: string; option: string }[]" }, required: !0 }, { name: "rules", description: "A set of vee-validate rules.", type: { name: "string | Record<string, unknown>" }, required: !0 }, { name: "description", description: "The description below the field.", type: { name: "string" }, defaultValue: { func: !1, value: "''" } }, { name: "readonly", type: { name: "boolean" }, defaultValue: { func: !1, value: "false" } }], events: [{ name: "update:value", type: { names: ["undefined"] } }], slots: [{ name: "description" }] };
const M = c({
  name: "FieldTextarea",
  data() {
    return {
      currentValidation: null
    };
  },
  emits: ["update:value"],
  setup(e) {
    const t = b(e, "alias"), s = b(e, "name");
    return {
      field: B(t, e.rules, {
        label: s,
        initialValue: e.value
      })
    };
  },
  watch: {
    value(e) {
      this.field.setValue(e);
    }
  },
  props: {
    alias: {
      type: String,
      required: !0
    },
    name: {
      type: String,
      required: !0
    },
    label: {
      type: String,
      required: !0
    },
    value: {
      type: String,
      default: null
    },
    rules: {
      type: [String, Object],
      required: !0
    },
    placeholder: {
      type: String,
      default: ""
    },
    description: {
      type: String,
      default: ""
    },
    readonly: {
      type: Boolean,
      default: !1
    }
  },
  methods: {
    publish() {
      this.field.handleBlur(), this.currentValidation = this.field.validate().then((e) => {
        this.currentValidation = null, e.valid && this.field.value.value !== null ? this.$emit("update:value", this.field.value.value) : this.$emit("update:value", "");
      });
    }
  }
});
const De = ["for"], Ee = ["name", "id", "placeholder", "readonly"], Re = {
  key: 0,
  class: "field-textarea__description"
}, Me = {
  key: 1,
  class: "field-textarea__error"
};
function Le(e, t, s, d, u, h) {
  return a(), i("div", {
    class: g({
      "field-textarea": !0,
      "field-textarea--invalid": e.field.errors.value.length > 0,
      "field-textarea--valid": e.field.errors.value.length <= 0 && e.field.meta.dirty
    })
  }, [
    r("label", {
      for: e.alias,
      class: "field-textarea__label"
    }, l(e.label), 9, De),
    F(r("textarea", {
      class: "field-textarea__textarea",
      name: e.alias,
      id: `field-${e.alias}`,
      placeholder: e.placeholder,
      readonly: e.readonly,
      "onUpdate:modelValue": t[0] || (t[0] = (n) => e.field.value.value = n),
      onBlur: t[1] || (t[1] = (...n) => e.publish && e.publish(...n)),
      onChange: t[2] || (t[2] = (...n) => e.field.handleChange && e.field.handleChange(...n))
    }, null, 40, Ee), [
      [G, e.field.value.value]
    ]),
    e.field.errors.value.length < 1 ? (a(), i("small", Re, [
      v(e.$slots, "description", {}, () => [
        w(l(e.description), 1)
      ])
    ])) : (a(), i("small", Me, l(e.field.errors.value[0]), 1))
  ], 2);
}
const Xe = /* @__PURE__ */ f(M, [["render", Le]]);
M.__docgenInfo = { displayName: "FieldTextarea", description: "Renders a textarea together with a label, description and validation.", tags: {}, exportName: "default", props: [{ name: "alias", description: "The name of the field in kebab-case.", type: { name: "string" }, required: !0 }, { name: "name", description: "The human readable name of the field.", type: { name: "string" }, required: !0 }, { name: "label", description: "The label above the field.", type: { name: "string" }, required: !0 }, { name: "value", type: { name: "string" }, defaultValue: { func: !1, value: "null" } }, { name: "rules", description: "A set of vee-validate rules.", type: { name: "string | Record<string, unknown>" }, required: !0 }, { name: "placeholder", type: { name: "string" }, defaultValue: { func: !1, value: "''" } }, { name: "description", description: "The description below the field.", type: { name: "string" }, defaultValue: { func: !1, value: "''" } }, { name: "readonly", type: { name: "boolean" }, defaultValue: { func: !1, value: "false" } }], events: [{ name: "update:value", type: { names: ["undefined"] } }], slots: [{ name: "description" }] };
export {
  He as AccordionList,
  Ge as AsyncButton,
  ae as BaseButton,
  Je as FieldInput,
  Ke as FieldSelect,
  Qe as FieldSwitch,
  Xe as FieldTextarea,
  T as IconDisplay,
  pe as ModalView,
  We as Styles
};
//# sourceMappingURL=open-election-compass-ui.es.min.js.map
